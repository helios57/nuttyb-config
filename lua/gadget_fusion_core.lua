function gadget:GetInfo()
  return {
    name      = "Singularity Fusion Core",
    desc      = "Merges 2x2 static structures into higher tier variants",
    author    = "NuttyB Team",
    date      = "2024",
    license   = "GPL",
    layer     = 0,
    enabled   = true
  }
end

if (not gadgetHandler:IsSyncedCode()) then
  return
end

-- Always enabled
local modOptions = Spring.GetModOptions() or {}

local spGetUnitPosition = Spring.GetUnitPosition
local spGetUnitDefID = Spring.GetUnitDefID
local spCreateUnit = Spring.CreateUnit
local spDestroyUnit = Spring.DestroyUnit
local spSetUnitNeutral = Spring.SetUnitNeutral
local spGetUnitHealth = Spring.GetUnitHealth
local spSetUnitHealth = Spring.SetUnitHealth
local spGetUnitsInCylinder = Spring.GetUnitsInCylinder
local spGetUnitExperience = Spring.GetUnitExperience
local spSetUnitExperience = Spring.SetUnitExperience

-- Map of Mergeable UnitDefID -> Next Tier UnitDefID
local mergeMap = {}
-- Map of UnitDefID -> Tier (1 to 5)
local unitTier = {}

function gadget:Initialize()
    -- Hardcoded base names that we know are generated by unit-generators.ts
    local baseNames = {"armsolar", "corsolar", "armwin", "corwin", "armmakr", "cormakr", "armllt", "corllt"}

    for _, name in pairs(baseNames) do
        -- T1 -> T2
        local u1 = UnitDefNames[name]
        local u2 = UnitDefNames[name .. "_t2"]
        if u1 then unitTier[u1.id] = 1 end
        if u1 and u2 then
             mergeMap[u1.id] = u2.id
             unitTier[u2.id] = 2
        end

        -- T2 -> T3, T3 -> T4, T4 -> T5
        for i = 2, 4 do
            local cur = UnitDefNames[name .. "_t" .. i]
            local next = UnitDefNames[name .. "_t" .. (i+1)]
            if cur then unitTier[cur.id] = i end
            if cur and next then
                 mergeMap[cur.id] = next.id
                 unitTier[next.id] = i+1
            end
        end
    end
end

function gadget:UnitFinished(unitID, unitDefID, teamID)
    local minTier = tonumber(modOptions.fusion_mintier) or 1
    local currentTier = unitTier[unitDefID] or 0
    if currentTier < minTier then return end

    local nextTierID = mergeMap[unitDefID]
    if not nextTierID then return end

    local x, _, z = spGetUnitPosition(unitID)
    local ud = UnitDefs[unitDefID]
    -- Spring footprint is in 16-elmo blocks. e.g. 2x2 footprint = 32x32 elmos.
    local fpX = ud.footprintX * 16
    local fpZ = ud.footprintZ * 16

    -- Search radius slightly larger than 2x footprint
    local searchRadius = math.max(fpX, fpZ) * 2
    local nearby = spGetUnitsInCylinder(x, z, searchRadius, teamID)

    local candidates = {}
    for _, uid in pairs(nearby) do
        if spGetUnitDefID(uid) == unitDefID and uid ~= unitID then
            local ux, _, uz = spGetUnitPosition(uid)
            table.insert(candidates, {id=uid, x=ux, z=uz})
        end
    end

    if #candidates < 3 then return end

    -- Helper to find unit at specific relative coordinates with tolerance
    local function FindAt(targetX, targetZ)
        for _, c in pairs(candidates) do
            if math.abs(c.x - targetX) < 8 and math.abs(c.z - targetZ) < 8 then
                return c.id
            end
        end
        return nil
    end

    -- Helper to execute merge
    local function ExecuteMerge(uTL, uTR, uBL, uBR)
        if uTL and uTR and uBL and uBR then
             -- Lock units
            spSetUnitNeutral(uTL, true)
            spSetUnitNeutral(uTR, true)
            spSetUnitNeutral(uBL, true)
            spSetUnitNeutral(uBR, true)

            local h1 = spGetUnitHealth(uTL) or 0
            local h2 = spGetUnitHealth(uTR) or 0
            local h3 = spGetUnitHealth(uBL) or 0
            local h4 = spGetUnitHealth(uBR) or 0

            -- Calculate average center
            local px1, _, pz1 = spGetUnitPosition(uTL)
            local px4, _, pz4 = spGetUnitPosition(uBR)
            local cx = (px1 + px4) / 2
            local cz = (pz1 + pz4) / 2

            -- Get XP from fused units
            local xp1 = spGetUnitExperience(uTL) or 0
            local xp2 = spGetUnitExperience(uTR) or 0
            local xp3 = spGetUnitExperience(uBL) or 0
            local xp4 = spGetUnitExperience(uBR) or 0
            local totalXP = xp1 + xp2 + xp3 + xp4

            -- Apply Efficiency Bonus
            local efficiency = tonumber(modOptions.fusion_efficiency) or 1.10
            totalXP = totalXP * efficiency

            -- Destroy source units
            spDestroyUnit(uTL, false, true)
            spDestroyUnit(uTR, false, true)
            spDestroyUnit(uBL, false, true)
            spDestroyUnit(uBR, false, true)

            -- Create new unit
            local newUnit = spCreateUnit(nextTierID, cx, 0, cz, 0, teamID)
            if newUnit then
                -- Sum HP from fused units and apply bonus
                local totalHealth = (h1 + h2 + h3 + h4) * efficiency
                -- Check max health of new unit to avoid overflow if needed,
                -- though usually SetUnitHealth clamps it or allows overflow.
                -- We set it to the sum.
                spSetUnitHealth(newUnit, totalHealth)

                -- Sum XP
                spSetUnitExperience(newUnit, totalXP)
            end
            return true
        end
        return false
    end

    -- Check 4 permutations where 'unitID' is one of the corners

    -- Case 1: This is TL. Check TR, BL, BR.
    if ExecuteMerge(unitID, FindAt(x+fpX, z), FindAt(x, z+fpZ), FindAt(x+fpX, z+fpZ)) then return end

    -- Case 2: This is TR. Check TL, BL, BR.
    if ExecuteMerge(FindAt(x-fpX, z), unitID, FindAt(x-fpX, z+fpZ), FindAt(x, z+fpZ)) then return end

    -- Case 3: This is BL. Check TL, TR, BR.
    if ExecuteMerge(FindAt(x, z-fpZ), FindAt(x+fpX, z-fpZ), unitID, FindAt(x+fpX, z)) then return end

    -- Case 4: This is BR. Check TL, TR, BL.
    if ExecuteMerge(FindAt(x-fpX, z-fpZ), FindAt(x, z-fpZ), FindAt(x-fpX, z), unitID) then return end
end

